# メトリクス

## メトリクスとは

読者は、健康診断というものを受けたことがあるでしょうか。
特に血液検査を受けると血液の成分を測定して、あなたの健康状態を多面的に評価を受けることができます。

ソースコードも、ソースコードの行数や構文の構造解析をして計測することで、「よみやすさ」を数値化できます。
血液検査と同じで、ひとつの指標だけでなく、多角的に計測することで、どのように読みにくいかを知ることができます。
このように計測した結果の事をメトリクスと呼び、プロジェクトではソースコードの健康状態をあらわす指標として限界値を設定します。
限界値を超えたソースコードは、以下のような修正をすることで、メトリクスを低下させます。

* 空白や改行、空行を追加する
* ファイルを分割する
* インタフェースを変更する
* 呼び出し階層を追加する
* アルゴリズムを変更する

ここでは、どのようなメトリクスがあるかを紹介します。
また、そのメトリクスを低減する手法についても紹介します。

## <i class="fa-solid fa-file blue-text"></i> ファイル単位のメトリクス

### カラム数

1行に書く文字数のことです。
90年代前半までは、ソースコードは、印刷して内容を確認することをしていました。
ディスプレイの解像度の問題もあり、1行あたり60桁～80桁という制限を設けていました。
90年代後半から、PCの普及に伴い、ペーパーレスが進んだため、印刷することをやめ、ソースコードは直接ディスプレイで見るようになりました。
ディスプレイの解像度も上がり、1行に多くの文字を表現できるようになりました。

また、別の角度から、人間の認知特性から、 **1行に100文字程度が限界** であるという研究報告もあります。

### ファイルの行数

ひとつのファイルに書くソースコードの行数のことです。
筆者は2000年代前半ひどいプロジェクトに出くわした。
あるファイルに 5,000行 を超える行が記述されたソースコードをメンテナンスした経験したことがあります。
しかも、そのファイルには2つの関数しか定義されていませんでした。
この例は特殊ですが、
**1ファイル当たりおよそ200～500行程度を上限**
にしておくと良いでしょう。

### ファイルに実装されたクラスの個数

プロジェクトを進めていると、「ひとつのファイルにはひとつのクラス(またはインタフェースや構造体)に納めるべき」というコード規約を決めることがあります。
実は、これについては **賛否両論** あります。

もちろん、「ひとつのファイルにひとつのクラスを実装する」という原則を守ったほうが以下のようなメリットはあります。

* ファイル名でそのクラスを探せる
* クラスの実装をカプセル化できる
* クラスの再利用が簡単になる

しかしながら以下の例のように、「ひとつのファイルに複数のクラス(インタフェース)を実装する」ことはあり得る。

```typescript
type EndOfLineType = 'cr' | 'lf' | 'crlf' | 'auto'
export interface TextFileReaderOptions {
    eol?: EndOfLineType,
    encoding?: string,
    codePage?: number
}

export class TextFileReader {
    protected constructor(options?: TextFileReaderOptions) {
        // ... implement here
    }
}
```

重要なことは、 **「ひとつのファイルはひとつの意味的クラス」に分割する** ことと筆者は考えます。

## <i class="fa-solid fa-cubes blue-text"></i> クラス単位のメトリクス

### メンバの個数

クラスのメンバは、10～20程度を上限とするのが理想といわれています。
それを超えると、よみやすさが低下し、テストが困難になるといわれています。

### 継承の深さ

「継承は少ないほうが良い」、「継承は3段まで」といわれていますが、筆者はその限りではないと考えています。
クラスやインタフェースがしっかり設計されており、巧みにカプセル化されてるのであれば、それはそれで問題はないと考えます。

実際、.NetやJavaの標準ライブラリには、3階層～5階層まで継承しているクラスも存在します。
巧みに設計されているライブラリではそこまで気になりません。

## <i class="fa-solid fa-person-running blue-text"></i> 関数やメソッドごとのメトリクス

### 関数やメソッドの行数

やはり1メソッドあたり100行が限界です。
それを超えると、もはやどんな機能を持つものか理解が追いつきません。

### 関数やメソッドの引数の数

あまりに多い引数を持つメソッドは忌み嫌われます。
したがって、引数の数を下げる工夫をするべきです。

下記の例は、テキストを読み込むメソッドのインタフェースです。
ファイルパス以外が、全てオプションとしてとらえて、構造体で渡すようにしました。
このように、「主引数」と「副引数」にカテゴリ分けをし、「主引数」を目立つように単体の引数として、「副引数」をひとつの構造体に納めます。

このように、引数にメリハリがついて格段に読みやすくなります。

:::tabs

@tab 悪い例

```typescript
export function readTextFile(
    filePath: string,
    eol?: EndOfLineType,
    encoding?: string,
    codePage?: number) {
    // .....
}
```

@tab 良い例

```typescript
export interface TextFileReaderOptions {
    eol?: EndOfLineType,
    encoding?: string,
    codePage?: number
}

export function readTextFile(filePath: string, options?: TextFileReaderOptions) {
    // .....
}
```

ただし、なんでもかんでも、まとめないほうがいいです。
かつて、筆者が遭遇したコードで、オプションがフラットな構造で、プロパティ(メンバ)が数十個存在するような設計に出くわしたことがあります。
高機能かもしれませんが、関数の呼び出し側を実装する開発者に対する「やさしさ」が足りません。

:::

::labeled-container-with-fa-icon{type="warning" label="引数 vs プロパティ"}

あるパラメタを引数にすべきか、そのクラスのフィールド(プロパティ)にすべきかは、悩ましいです。
実はこの問題には、普遍的な解はありません。
ですので、実装者(設計者)が最後の最後まで苦悩し悩んで決めるべき事柄です。

```typescript
class TextFileReader {
    encoding: string;

    await readNext(): Promise<string> {
        // ....
    }
}
```

この例では、`encoding` をフィールドに設定しています。
この場合、このクラスは、行ごとに文字コードを変更しない仕様です。
大半の場合はこの設計で問題ありませんが、ケースによってはこれが最善とは限りません。

::

### 関数やメソッドの循環的複雑度

関数やメソッドの **循環的複雑度(CC値とも呼ばれます。)** という尺度があります。
これは、処理フロー図を書いた際に、そのフロー図がどれだけ複雑かをあらわす値です。
これは、フロー図を点と線と見た際その図形がどれだけ複雑かをあらわす数学的指標です。

計算式は様々な定義があり、この値を計測するソフトウェアに依存します。
共通して言えることは、分岐や繰り返しが多く登場すると、その分この値が増えます。

10を超えるとメンテナンス不可能という研究報告もあります。
なので、初期開発では7以下に抑える努力をしましょう。

::labeled-container-with-fa-icon{type="tip"}

最近のIDEや静的解析ツールには、この循環的複雑度を計測し、あまりにも大きい場合は、警告を出力するソフトウェアがあります。
可能な限り、このような警告を出力するようにしておきましょう。

* [Code Metrics - Visual Studio Code Extension](https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-codemetrics)
* [complexity - ESLint](https://archive.eslint.org/docs/rules/complexity)

::

### 呼び出し階層

呼び出し階層も浅いほうが良いとされていますが、筆者はその限りではないと考えます。
特に、呼び出される関数が、別ファイルに存在しその関数の機能が簡単に推測できる
[名づけ](naming.md)
になっていれば、その限りではないと考えます。

::labeled-container-with-fa-icon{type="note"}

このように、呼び出される機能(関数)が、別ファイルに存在していたとします。
その関数の名前が機能を簡単に推測できるようになっている状態を **カプセル化に成功した** と呼び、推奨されるべき状態と筆者は考えます。

::
